<?xml version="1.0"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"> <channel> <title>CL-USER&gt; (start-up (the engine *bp-ze*))</title> <link>https://guicho271828.github.io</link> <atom:link href="https://guicho271828.github.io/rss.xml" rel="self" type="application/rss+xml" /> <language>en-us</language> <pubDate>Sat, 18 Nov 2017 17:17:02 +0900</pubDate> <item> <title>2017-11-06</title> <link>https://guicho271828.github.io/posts/2017-11-06.html</link> <pubDate>2017-11-06 16:04:54</pubDate> <author>Masataro Asai</author> <guid isPermaLink="true">https://guicho271828.github.io/posts/2017-11-06.html</guid> <category><![CDATA[ lisp ]]></category> <description><![CDATA[ <!-- **** your post here (remove this line) **** -->

<!-- format: could be 'html' (for raw html) or 'md' (for markdown).  -->

<p>I just migrated from Jekyll to Coleslaw.</p>

<!--more-->

<p>This was not the best experinece, but was fun anyways.</p>
 ]]></description> </item><item> <title>Recursive Macroexpansion</title> <link>https://guicho271828.github.io/posts/Recursive-Macroexpansion.html</link> <pubDate>2014-05-04 15:56:33 +0900</pubDate> <author>Masataro Asai</author> <guid isPermaLink="true">https://guicho271828.github.io/posts/Recursive-Macroexpansion.html</guid> <category><![CDATA[ old-blog ]]></category><category><![CDATA[ lisp ]]></category> <description><![CDATA[ <blockquote>
<p>Yesterday, as a holiday coding, I made yet another macro-expansion system which
allows for easier compile-time error handling, which I previously described in
<a href="http://qiita.com/guicho271828/items/07ba4ff11bff494dc03f" >this post</a>.</p>
</blockquote>

<p>昨日、ゴールデンウィークの遊びコーディングとして、
<a href="http://qiita.com/guicho271828/items/07ba4ff11bff494dc03f" >前々から言っていた</a> ものに相当する、
リスタートやコンディションと密に連携できるマクロ展開システムを作りました。</p>

<!--more-->

<blockquote>
<p>Some people may already know that this idea is not so new at all.
In 
<a href="http://ja.reddit.com/r/lisp/comments/1xyux9/macro_system_common_lisp_is_still_hard_to_satisfy/cffz33l" >this post</a>
, nsiivola said that we can alternatively use an implementation-specific
<code>macroexpand-all</code>. Also, <code>macroexpand-dammit</code> tries to give the similar feature
within ANSI CL.</p>
</blockquote>

<p>色々とすでに言われているように実は、
このライブラリ自体にそんなに新規性はありません。
まず、同じことを達成するためには、
<a href="http://ja.reddit.com/r/lisp/comments/1xyux9/macro_system_common_lisp_is_still_hard_to_satisfy/cffz33l" >nsiivola さんの言った</a>ように、
マクロの中で実装依存の <code>macroexpand-all</code> を使うという手がありました。
他にも、ANSI CL の中だけで似た機能を作ろうと頑張っている、
 <code>macroexpand-dammit</code> を使うという手もありました。</p>

<blockquote>
<p>So why I made it? The first reason is that I didn't want to use the implementation
specific feature. The second is that, I didn't want to use <code>macroexpand-dammit</code>
which I have a bitter experience with it.
When I once saw it, it was not maintained, the implementation was tricky,
it has a bug, lacks test codes, and was also depended by some other famous library SXML, which I have no idea
about and also lacks test codes.</p>
</blockquote>

<p>ではなぜ作ったのか?
第一に、実装依存の要素を使うというのはあまり好きではありませんでした。
第二に、これは完全に個人的な理由なんですが、
<code>macroexpand-dammit</code> には苦い経験があるのであまり使いたくなかったというわけです。
このライブラリ、まず実装がトリッキー、バグが在る、テストコードがない、という問題だ
らけのライブラリでした。</p>

<blockquote>
<p>I once tried to maintain it on github and have my repo followed in quicklisp thanks to
zach, but my change made some errors in those dependent libraries, and
honestly I failed. I neglected. Currently quicklisp follows the older version. 
And I lack my interest now. (However, now I see some issues
message from someone, so maybe I'll try again)</p>
</blockquote>

<p>一度、これを直してgithub上でメンテナっぽく振る舞おうと思い、quicklispにも申請したの
ですが、
これを治そうとすると、実は有名なライブラリSXMLがこれに依存しているらしく、そこのコー
ドを壊してしまうそうです。
で、さらに悪いことに、「メンテナになるよー」と一旦言ったにも関わらず
個人的に時間が取れなくて放置してしまったため、
zachさんには「メンテ出来ないならメンテナになろうとするな」と。正論ですね。すみませ
ん。そんなこんなで、苦い経験だったので触りたくなかったのです。(なんか今見たら
issueが飛んできていますね・・・そろそろ頑張り直すかも。)</p>

<blockquote>
<p>Recursive-Macroexpansion has the completely different expansion algorithm than
those of Common Lisp’s macro expansion. CL is based on macroexpand-1 and
macroexpand while Recursive-Macroexpansion is based on rmacroexpand only. However,
normal macros are transparent to macroexpand, so mixing normal macro and recursive
macro is completely ok.</p>
</blockquote>

<p>Recursive-Macroexpansion は普通の Common Lisp の展開とは別のアルゴリズムで
式を展開します。 CL での展開は macroexpand-1 と
macroexpand でできていますが、 Recursive-Macroexpansion は <code>rmacroexpand</code> だけで出
来ています。 <code>rmacroexpand</code> は、対応する recursive-macro がなかった場合
普通の <code>defmacro</code> で定義されたマクロを探し、普通の <code>macroexpand-1</code> で展開するので、
<code>recursive-macro</code> と普通のマクロを混ぜることは全く問題ありません。</p>

<blockquote>
<p><strong>BIG NOTE</strong> : This is my FIRST library written in controversial CL21. Thanks to
Fukamachi !  The reason I chose CL21 is simply because I was interested in it and
want to try it. However, adoption of <em>CLtL2 Sec.8 environment</em> was also a key
factor, because it uses <code>augment-environment</code> many times.</p>
</blockquote>

<p>これはまあCL21で作った最初のライブラリです。使いながらCL21のバグフィック
スもいくつかしました。 深町さんGJ!
CL21を使った理由は、まあ使ってみて感触を試してみたかったというのもありますが、
CLtL2の <code>&amp;environment</code> 構造体関連の関数がCL21ではデフォルトで入っているというのが
鍵でした。実装は <code>augment-environment</code> に多分に依存しています。(これをしてしまうと、
実装依存の <code>macroexpand-all</code> とどう違うんだと言われてしまうかもしれませんが・・・)</p>

<p><a href="https://github.com/guicho271828/recursive-macroexpansion">https://github.com/guicho271828/recursive-macroexpansion</a></p>

<p>Lisp on OpenCL は少しずつやってますがあんまり進展はないので、次回はマクロの話をまた
英語併記でやります。</p>
 ]]></description> </item><item> <title>Project started: lisp on opencl</title> <link>https://guicho271828.github.io/posts/Project-started-lisp-on-opencl.html</link> <pubDate>2014-03-22 11:35:03 +0900</pubDate> <author>Masataro Asai</author> <guid isPermaLink="true">https://guicho271828.github.io/posts/Project-started-lisp-on-opencl.html</guid> <category><![CDATA[ old-blog ]]></category><category><![CDATA[ lisp ]]></category> <description><![CDATA[ <p>Radeon HD5770と nVidia TESLA c1060 およびニュー電源を手に入れたので、
この一週間は、
C言語のサブセットであるOpenCLにコンパイルされるlisp拡張を制作する予定。
まあ、肝心のビデオカードがまだ動いていないんだけど・・・</p>

<!--more-->

<p>なぜかというと、GPU用の補助電源ケーブルの手持ちがないから。
やろうと思えば自作もできるんだけど、さすがにこれぐらい買おうかなと思う・・・</p>

<p>なお、試しに電源を入れてみた(補助電源無し)ときには、おそらくきちんと動いていない
からかものすごいファンがうるさかった。</p>

<p>{{ 'gallery' | image_list }}</p>
 ]]></description> </item><item> <title>＾がlambdaの省略として使いにくいという話</title> <link>https://guicho271828.github.io/posts/がlambdaの省略として使いにくいという話.html</link> <pubDate>2014-03-01 10:34</pubDate> <author>Masataro Asai</author> <guid isPermaLink="true">https://guicho271828.github.io/posts/がlambdaの省略として使いにくいという話.html</guid> <category><![CDATA[ old-blog ]]></category><category><![CDATA[ lisp ]]></category> <description><![CDATA[ <p>お久しぶりです、浅井です。</p>

<p>論文やばかったり人の論文読んだりgithubで議論したりする毎日ですが、
表題の通りの議題について。</p>

<!--more-->

<p>じつは、自分 <strong>括弧</strong> を書くのがshiftキーのせいで結構苦痛に感じています。
ええ、lisperなのにです。</p>

<p>いや、括弧は好きなんです。好きなんですよ?大好きです。
でも、僕は手がかなり小さい。
&lt;Right-shift + 8&gt; は人差し指と小指を最大限伸ばして押すことになります。
そう、さながらメロイック・サインみたいなカンジで入力しています。</p>

<p>それでですね、二年くらい前、 <em>数字キーのそのシフトキーのXmodmapを入れ替えてみた</em>
ことがあったんですよ。結局慣れずにもとに戻してしまいましたが。</p>

<p>(通常)</p>

<pre><code>keycode  10 = 1 exclam 1 exclam
keycode  11 = 2 quotedbl 2 quotedbl
keycode  12 = 3 numbersign 3 numbersign
keycode  13 = 4 dollar 4 dollar
keycode  14 = 5 percent 5 percent
keycode  15 = 6 ampersand 6 ampersand
keycode  16 = 7 apostrophe 7 apostrophe
keycode  17 = 8 parenleft 8 parenleft
keycode  18 = 9 parenright 9 parenright
keycode  19 = 0 asciitilde 0 asciitilde
</code></pre>

<p>(入れ替え)</p>

<pre><code>keycode  10 = exclam 1 exclam 1
keycode  11 = quotedbl 2 quotedbl 2
keycode  12 = numbersign 3 numbersign 3
keycode  13 = dollar 4 dollar 4
keycode  14 = percent 5 percent 5
keycode  15 = ampersand 6 ampersand 6
keycode  16 = apostrophe 7 apostrophe 7
keycode  17 = parenleft 8 parenleft 8
keycode  18 = parenright 9 parenright 9
keycode  19 = asciitilde 0 asciitilde 0
</code></pre>

<p>だって、lisp書く最中で数字ってそんなに使いませんよ。なにに使うんですか。
精々使っても 0 か 1 しか無いと思うんですよ。7とか8とか何時使うんですか。
だったら数字のキーだけ常にCapsLock状態のほうがいいじゃないですか。
括弧に殉ずるべきです。 <em>すべてはparenthesesのもとに！</em></p>

<p>これと同じ考え方をやれば、(まあ自分のキーボードでは <code>^</code> に shift は要りませんが)
<code>^</code> をshift無しで入力することも簡単だと思います。
あるいは、 <code>cl21-mode</code> みたいなマイナーモード作るとか。</p>

<p>というわけです。括弧のためにキーアサインを変更する・・・。
だれか真似してみたい人はいませんか。</p>
 ]]></description> </item><item> <title>紹介: ライブラリ Inner-conditional</title> <link>https://guicho271828.github.io/posts/紹介-ライブラリ-Inner-conditional.html</link> <pubDate>2013-05-06 20:41</pubDate> <author>Masataro Asai</author> <guid isPermaLink="true">https://guicho271828.github.io/posts/紹介-ライブラリ-Inner-conditional.html</guid> <category><![CDATA[ old-blog ]]></category><category><![CDATA[ lisp ]]></category> <description><![CDATA[ <p><a href="https://github.com/guicho271828/inner-conditional" >inner-conditional</a> の紹介をします。</p>

<h1>Q.なにができるの?</h1>

<p>A. ループ(など)の中の条件判定を、内側に書いたままで外側に出せます。</p>

<!--more-->

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">with-inner</span></i> <span class="paren2">(<span class="code">body</span>)</span>
    <span class="paren2">(<span class="code">iter <span class="paren3">(<span class="code">for i from 0 to 5</span>)</span>
          <span class="paren3">(<span class="code">print i</span>)</span>
          <span class="paren3">(<span class="code">inner <span class="paren4">(<span class="code">body</span>)</span>
            <span class="paren4">(<span class="code"><i><span class="symbol">if</span></i> flag
                <span class="paren5">(<span class="code">body <span class="paren6">(<span class="code">princ <span class="string">"loop on"</span></span>)</span></span>)</span>
                <span class="paren5">(<span class="code">body <span class="paren6">(<span class="code">princ <span class="string">"loop off"</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span></code></pre>

<p>と書くと、</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">IF</span></i> FLAG
    <span class="paren2">(<span class="code"><i><span class="symbol">WITH-INNER</span></i> <span class="paren3">(<span class="code">BODY</span>)</span>
      <span class="paren3">(<span class="code">ITER
        <span class="paren4">(<span class="code">FOR I FROM 0 TO 5</span>)</span>
        <span class="paren4">(<span class="code">PRINT I</span>)</span>
        <span class="paren4">(<span class="code"><i><span class="symbol">PROGN</span></i> <span class="paren5">(<span class="code">PRINC <span class="string">"loop on"</span></span>)</span></span>)</span></span>)</span></span>)</span>
    <span class="paren2">(<span class="code"><i><span class="symbol">WITH-INNER</span></i> <span class="paren3">(<span class="code">BODY</span>)</span>
      <span class="paren3">(<span class="code">ITER
        <span class="paren4">(<span class="code">FOR I FROM 0 TO 5</span>)</span>
        <span class="paren4">(<span class="code">PRINT I</span>)</span>
        <span class="paren4">(<span class="code"><i><span class="symbol">PROGN</span></i> <span class="paren5">(<span class="code">PRINC <span class="string">"loop off"</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span>
</span></code></pre>

<p>になって、</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">IF</span></i> FLAG
    <span class="paren2">(<span class="code"><i><span class="symbol">PROGN</span></i>
     <span class="paren3">(<span class="code">ITER
       <span class="paren4">(<span class="code">FOR I FROM 0 TO 5</span>)</span>
       <span class="paren4">(<span class="code">PRINT I</span>)</span>
       <span class="paren4">(<span class="code"><i><span class="symbol">PROGN</span></i> <span class="paren5">(<span class="code">PRINC <span class="string">"loop on"</span></span>)</span></span>)</span></span>)</span></span>)</span>
    <span class="paren2">(<span class="code"><i><span class="symbol">PROGN</span></i>
     <span class="paren3">(<span class="code">ITER
       <span class="paren4">(<span class="code">FOR I FROM 0 TO 5</span>)</span>
       <span class="paren4">(<span class="code">PRINT I</span>)</span>
       <span class="paren4">(<span class="code"><i><span class="symbol">PROGN</span></i> <span class="paren5">(<span class="code">PRINC <span class="string">"loop off"</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span>
</span></code></pre>

<p>になります。うふふ、いいでしょ。キモイ？</p>

<p>この種のループ最適化というと、もとから全て行なってくれるような、とって
も優れた処理系もあるかもしれませんが、なにせ実際に動いているのかどうか
わかりません。(C言語とかって、賢いコンパイラはこういうのが全部デフォルト
で付いているんですかね？) sbclでテストをした結果、 <strong>たしかに</strong> <a href="https://github.com/guicho271828/inner-conditional/blob/master/opt-results.org" >条件判定
の分だけ早くなっていることが確認出来ました。</a></p>

<p>条件判定のタイミングは <code>with-inner</code> の部分ですので、 <code>with-inner</code> をど
こに置くかで判定のタイミングを適切に設定できます。</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">with-inner</span></i> <span class="paren2">(<span class="code">body</span>)</span>
  <span class="paren2">(<span class="code">iter <span class="paren3">(<span class="code">for i from 0 to 5</span>)</span>
        <span class="paren3">(<span class="code"><i><span class="symbol">with-inner</span></i> <span class="paren4">(<span class="code">body2</span>)</span>
          <span class="paren4">(<span class="code">iter <span class="paren5">(<span class="code">for j from 0 to 5</span>)</span>
                <span class="paren5">(<span class="code">format t <span class="string">"~%i: ~a j: ~a"</span> i j</span>)</span>
                <span class="paren5">(<span class="code">inner <span class="paren6">(<span class="code">body2</span>)</span>
                  <span class="paren6">(<span class="code"><i><span class="symbol">if</span></i> <span class="paren1">(<span class="code">evenp i</span>)</span>
                      <span class="paren1">(<span class="code">body2 <span class="paren2">(<span class="code">format t <span class="string">"  i is even"</span></span>)</span></span>)</span>
                      <span class="paren1">(<span class="code">body2 <span class="paren2">(<span class="code">format t <span class="string">"  i is odd"</span></span>)</span></span>)</span></span>)</span></span>)</span>
                <span class="paren5">(<span class="code">inner-if body flag
                          <span class="paren6">(<span class="code">format t <span class="string">"  loop on"</span></span>)</span>
                          <span class="paren6">(<span class="code">format t <span class="string">"  loop off"</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span></code></pre>

<p>この例では、 <code>body</code> レベルでの条件判定は一番上で、一方 <code>body2</code> レベルの
条件判定はループの二段目で行えます。 <code>inner</code> の方、すなわり条件判定の内
容を実際に書いている方で、そのレベルを指定できます。 <code>(inner-if body
...)</code> というのは構文糖で、 <code>(inner (body) (if ... (body ...)))</code> に展開
されるマクロです。ほかにも数種類あります。</p>

<p><code>inner</code> 内で使えるのは <code>if</code> だけじゃありません。 <code>cond</code> でも、 <code>case</code>
でも、オレオレマクロでもなんでも大丈夫です。特殊なマクロで制御構造を登
録する必要はありません。必要なのはこれだけ、すなわち、</p>

<pre><code>継続であるかのように body を呼ぶこと
</code></pre>

<p>です。</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">with-inner</span></i> <span class="paren2">(<span class="code">body</span>)</span>
  <span class="paren2">(<span class="code">iter
    <span class="paren3">(<span class="code">for i from 0 to 5</span>)</span>
    <span class="paren3">(<span class="code">inner <span class="paren4">(<span class="code">body</span>)</span>
      <span class="paren4">(<span class="code">case <span class="paren5">(<span class="code"><i><span class="symbol">progn</span></i> <span class="paren6">(<span class="code">incf count</span>)</span>
                   <span class="paren6">(<span class="code">mod arg 3</span>)</span></span>)</span>
        <span class="paren5">(<span class="code">0 <span class="paren6">(<span class="code">body <span class="paren1">(<span class="code">format t <span class="string">"divided. i*3 =~a~%"</span>
                         <span class="paren2">(<span class="code">* i 3</span>)</span></span>)</span>
                 <span class="paren1">(<span class="code">format t <span class="string">"divided. i*3 =~a~%"</span>
                         <span class="paren2">(<span class="code">* i 3</span>)</span></span>)</span></span>)</span></span>)</span>
        <span class="paren5">(<span class="code">1 <span class="paren6">(<span class="code">body <span class="paren1">(<span class="code">format t <span class="string">"modulo 1. i*3 + 1 =~a~%"</span>
                         <span class="paren2">(<span class="code">+ 1 <span class="paren3">(<span class="code">* i 3</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span>
        <span class="paren5">(<span class="code">2 <span class="paren6">(<span class="code">body <span class="paren1">(<span class="code">format t <span class="string">"modulo 2. i*3 + 2 =~a~%"</span>
                         <span class="paren2">(<span class="code">+ 2 <span class="paren3">(<span class="code">* i 3</span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span>)</span></span></code></pre>

<p>だってほら、全然違いますけど、内側と外側がひっくり返るじゃないですか。
プログラムは実際には <strong>一番最初に</strong> 条件分岐をして、そして <code>inner</code> の中身
が <code>body</code> の引数を代入した状態で実行されるんです。似てませんか？ <strong>継続
に！</strong></p>

<p>続きはまた今度。このライブラリのもうひとつのいいところ、 あなたのライブ
ラリに、 <strong>条件分岐を隠したまま最適化できる能力</strong> を与えられる点について
お話しします。</p>
 ]]></description> </item><item> <title>Common Lisp で Code Walker を実装するなら その②</title> <link>https://guicho271828.github.io/posts/Common-Lisp-で-Code-Walker-を実装するなら-その②.html</link> <pubDate>2013-05-06 15:26</pubDate> <author>Masataro Asai</author> <guid isPermaLink="true">https://guicho271828.github.io/posts/Common-Lisp-で-Code-Walker-を実装するなら-その②.html</guid> <category><![CDATA[ old-blog ]]></category><category><![CDATA[ lisp ]]></category> <description><![CDATA[ <p>前回の続き。状態を持つmacroletを書くにはどうすればいいのか！？
これが答えだ！</p>

<!--more-->

<h1>回答: Compile-time で restart-bind</h1>

<p>{% include_code サンプルコード lang:cl walk-tree.lisp %}</p>

<p>ね、面白いでしょ？ANSI Hyperspecにある <code>*macroexpand-hook*</code> をうまく使っ
てみました。 <code>my-macro-start</code> が変な感じになっているのは、ここで書いた
構造が入れ子になってる可能性があるので、スタックフレームをエミュレート
しているんです。 <strong>ん、え、スタック？</strong></p>

<p>Schemerな人は言いたいことがすぐにわかることでしょう。ANSIの設計の何が悪
いって、 <code>defmacro</code> が <strong>継続を引数に取ってくれない</strong> ことなんですよ。だ
から、外側のマクロを展開した時に、内側のマクロ展開を行うときのレキシカ
ル環境を操作できない。それだから中途半端な code-walker しか <em>簡単には</em>
実装できないわけです。</p>

<p>うーん、えーと、もう2,3個思いついたはずなんですけど、思いつかなかった
ので、一つです。なにか他に案がある人はtwitterかgithub経由で教えてくだ
さい(^^)</p>
 ]]></description> </item><item> <title>Common Lisp で Code Walker を実装するなら</title> <link>https://guicho271828.github.io/posts/Common-Lisp-で-Code-Walker-を実装するなら.html</link> <pubDate>2013-05-05 22:01</pubDate> <author>Masataro Asai</author> <guid isPermaLink="true">https://guicho271828.github.io/posts/Common-Lisp-で-Code-Walker-を実装するなら.html</guid> <category><![CDATA[ old-blog ]]></category><category><![CDATA[ lisp ]]></category> <description><![CDATA[ <p>Common Lispを使っていると、みんな一度はマクロでDSLを実装したくなります
よね。みなさんどうしてるでしょう。例えば、自分の作ったマクロ
<code>my-macro</code> の中では、特定のS式、たとえば=my-clause= に特殊な意味を持つ
節としての役割を与えたい時。マクロは引数のS式を好きに扱えるので、なんで
もありです。だから、例えば。</p>

<!--more-->

<pre><code>
(defun walk-tree (fn tree)
  (funcall fn tree
           (lambda (branch)
             (mapcar (lambda (branch)
                       (walk-tree fn branch))
                     branch))))

(defun precompile-1-layer (sym fn form)
  (walk-tree
   (lambda (subform cont)
     (if (and (consp subform)
              (equalp sym (car subform)))
         (apply fn (cdr subform))
         (if (consp subform)
             (funcall cont subform)
             subform)))
   form))</code></pre>

<p>みたいなのを定義して、該当シンボルを手動で検知して <code>macroexpand</code> の真似
をする、といった手を使うことができちゃいます。</p>

<pre><code>
(defmacro my-macro (&body body)
  `(progn
     ,@(precompile-1-layer
        'my-clause
        (lambda (&body body)
          (progn (print :hi!)
                 ,@body))
        body)))

(my-macro
 (iter (for i below 5)
       (print i)
       (my-clause
        (print :stupid!))))

;; macroexpansion result

(progn
  (iter (for i below 5)
        (print i)
        (progn
          (print :hi!)
          (print :stupid!))))  
</code></pre>

<p>いやまあ、ここで問題になるのが、 <code>macrolet</code> で指定した内容が全然反映され
ないという事ですね。一言で言えば、頭悪い。</p>

<pre><code>
(my-macro
 (macrolet ((my-clause (&body body)
              (subst :im-not-stupid! :stupid! body)))
   (iter (for i below 5)
         (print i)
         (my-clause
          (print :stupid!)))))
</code></pre>

<pre><code>
(progn
 (macrolet ((my-clause (&body body)
              (subst :im-not-stupid! :stupid! body)))
  (iter (for i below 5)
        (print i)
        (progn
          (print :hi!)
          (print :stupid!)))))
</code></pre>

<p>my-clauseをバイパスして展開してしまっているので、内側のmy-clauseが反映
されず、 <code>:stupid!</code> が <code>:im-not-stupid!</code> に変換されずに残っている。この問
題が、<a href="http://m2ym.github.io/blog/2012/04/28/eval-in-macros/" >m2ymさんも言っている</a> <strong>マクロ内でevalするな</strong> 問題です。</p>

<p>でも、evalしないって辛いです。code walkをするなと言っているのと同様。
じゃあどうすればいいのか。</p>

<h1>全部Macroletに展開する</h1>

<p>これは僕が <a href="https://github.com/guicho271828/inner-conditional" >inner-conditional</a> ではじめに取った手法です。
<code>macrolet</code> をどんどんネストさせるわけです。</p>

<pre><code>
(defmacro my-macro (&body body)
  `(macrolet ((my-clause (&body body)
                `(progn (print :hi!)
                        ,@body)))
     ,@body))
</code></pre>

<p>これで今回のコードでは当面の目標は達成されます。でも、問題が・・・。な
にが問題かというと、コンパイル時に変数を触ることができないということ。
例えば上のコードで、</p>

<pre><code>一回目は〇〇に展開し、二回目は☓☓に展開したい。
</code></pre>

<p>とか、</p>

<pre><code>i回目にはiを用いて … に展開したい。その指定は実行時ではダメで、
コンパイル時に定数として挿入したい。
</code></pre>

<p>とかいう需要があるときにどうするか。</p>

<p><code>macrolet</code> はスペシャルフォームなので、そのマクロ定義だけをletで囲む
なんてことはできません。出来れば嬉しいんだけれどねえ…</p>

<pre><code>
(macrolet ((let ((i 0))
             (my-clause (&body body)
                (incf i)
                `(progn (print ,i)
                        ,@body))))
  (do-something))
</code></pre>

<p>ではどうするか。例を示そうと思ったんですが、例を書くだけでも骨が折れる
ようなコードだったので、続きは次の記事で。</p>
 ]]></description> </item><item> <title>オレオレlisp入門</title> <link>https://guicho271828.github.io/posts/オレオレlisp入門.html</link> <pubDate>2013-03-28 18:03</pubDate> <author>Masataro Asai</author> <guid isPermaLink="true">https://guicho271828.github.io/posts/オレオレlisp入門.html</guid> <category><![CDATA[ old-blog ]]></category><category><![CDATA[ lisp ]]></category> <description><![CDATA[ <p>Lispでプログラミングをはじめるには何をすればいいのか、まさに直接的な
チュートリアルをつくろうと思い立ち、この記事を書き始めました。</p>

<p>古いし読むに耐えない記事なので削除! (2016/3/30)</p>
 ]]></description> </item> </channel> </rss>